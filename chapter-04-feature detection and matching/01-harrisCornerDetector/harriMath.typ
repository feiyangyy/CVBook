#let dx=$delta x$
#let dy=$delta y$
#let bm=$bold(M)$
#let br=$bold(R)$
=== 哈里斯角点检测相关要点
核心思路是把一个逻辑问题转变成一个数学极值问题，在约束$S_W(dx,dy)=1$的框架下，可以确定一个轨迹，轨迹越小，说明越接近一个角点


关联的数学知识:
1. 一维和多维泰勒展开，对原始表达式$S_w(delta x, delta y)$ 做近似， 最终可以得到一个近似:$(dx, dy)bold(M)vec(dx, dy)$
2. $bold(M)$是一个实对称矩阵，并且上面所说的轨迹唯一由$bold(M)$确定
3. $bold(M)$在大多数case下都是正定的, 因此其可以表达为:$bm = br mat(lambda_1, 0; 0, lambda_2)br^T$, 其中$br in S O(2)$, $br$ 决定了轨迹椭圆的朝向，特征值$vec(lambda_1, lambda_2)$ 决定了椭圆的大小， 椭圆的大小和特征值大小成反比关系
4. 早期的角点检测实现是对$bold(M)$进行特征值分解，但是在做角点检测是，每个像素都去做一次特征值分解，实现效率很低
5. 哈里斯通过代数推到得到一个经验公式:
$
  R = det(bm) - k dot (tr(bm))^2 = lambda_1 lambda_2 - k (lambda_1 + lambda_2)^2
$
上面的$k in[0.04, 0.06]$是一个经验参数， 这个公式可以正确区分:
1. 平坦区域 (R比较小)
2. 边缘 (R 近似为负)
3. 角点 (R 很大)

=== 图像偏导数矩阵
#let ix = $I_x$
#let iy = $I_y$

对于数字图像而言，图象在两个方向上的梯度通常用sobel 算子:
$
  X=mat(-1, 0, 1; -2, 0, 2; -1, 0, 1);\
  Y=mat(-1, -2, -1; 0, 0, 0; 1, 2, 1);
$

每个像素点，可以构造二阶矩阵():
$
  M(x,y) = mat(I_x^2 , I_x I_y; I_x I_y, I_y^2); 
$
考虑到噪声原因，一般是用高斯kernel进行加权平均得到:
$
  M(x,y) = mat(sum w(u,v) I_x^2(u,v), sum w(u,v) I_x I_y(u,v); sum w(u,v) I_x I_y(u,v), sum w(u,v) I_y^2(u,v));
$
$w(u,v)$ 是高斯权重，用于加权平均

这里的$M(x,y)$ 也称为结构张量 (structure tensor)

然后再回到经验公式:
$
  R = det(bm) - k dot (tr(bm))^2 = lambda_1 lambda_2 - k (lambda_1 + lambda_2)^2 =>\
  R = (I_x^2I_y^2 - (ix iy)^2) -k (ix^2 + iy^2)
$
工程化实现：
1. 灰度化
2. 用Sobel得到#ix, #iy
3. 构造二阶项，计算$ix^2, iy^2, ix iy$
4. 平滑（高斯滤波）
5. 计算响应函数R
6. 非极大抑制，保留局部最大值

=== 哈里斯的角点的特征
1. 旋转不变: 哈里斯角点通过结构张量获取的轨迹描述是旋转不变的，可以理解为虽然角点的椭圆朝向会变，但是椭圆的大小不会变，角点检测也不会变
2. 尺度不变: 因为检测窗口不是随着图像尺度变化而变化的，因此哈里斯角点检测不是尺度不变的，#highlight()[需要引入多尺度分析]
3. 光照不变: 线性光照变化(整体变亮或变暗)不会影响梯度的方向，因此不会影响角点检测； 但如果是局部光照变化，则会影响梯度检测结果。因此哈里斯角点算法只具备部分光照不变性
 